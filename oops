# OOPS(PYTHON)

# What is oop?

膆 oop is a programming model that organizes code by grouping related data and the funcƟons that
work on that data into classes and objects.
It is a programming approach where we design soŌware using objects, similar to real-world enƟƟes
This makes the code modular, easier to manage, easier to reuse, and safer because internal details
can be hidden using encapsulaƟon.”

If they ask “How does it organize the code?”, say this:

膆 “It keeps everything related in one place. Instead of separate variables and funcƟons scaƩered
across the program, OOP bundles them together into objects. This structure makes large applicaƟons
easier to understand, maintain, and extend.”

#just for your understanding
“In OOPS, a system means a complete and organized approach where objects, classes, and rules
work together to build soŌware.”
what does organized approach means

膆膊 Everything has a proper place
 Data and funcƟons related to the same thing are kept inside one class
 Example: Bank account data and operaƟons stay inside the Account class

踰踱踲踳 No scaƩered code

膆膋 Clear structure
 Large programs are divided into small classes
 Each class has a specific responsibility
踰踱踲踳 Easy to understand and manage

膆膌 Rules are followed
 Data is protected using encapsulaƟon
 Code is extended using inheritance
 Same method works differently using polymorphism


踰踱踲踳 Code behaves predictably

膆膍 Easy to change and grow
 If one feature changes, only that class is updated
 New features are added without breaking exisƟng code
踰踱踲踳 Supports maintainability and scalability

Real-world example: A Bank Account
“Think of a bank account.
The balance and account number are the data.
Deposit and withdraw are the funcƟons.
In OOP, both the data and the funcƟons are bundled together into an Account class.
So everything related to a bank account stays inside one organized unit.”

#### “OOPS is a system, and Python and Java are languages used to implement

#### that system.”

In OOPS, “System” means: OOPS provides a complete framework that includes: Objects (real-world
enƟƟes) Classes (blueprints) Rules (encapsulaƟon, inheritance, polymorphism, abstracƟon)
InteracƟons between objects All these together form a system for building soŌware.

### Class and objects

“All members of class stored in obj dict” ** WRONG**
 Only instance variables (aƩributes created with self) are stored in obj.__dict__.


```
 Methods and class variables are not copied into the object. They stay in the class
dicƟonary (C_name.__dict__).
```
Classes are blueprints or templates for creaƟng objects. They define what aƩributes and methods
the objects will have.
An object is an instance of a class. It represents a real-world enƟty and holds actual values for the
aƩributes defined in the class.
Each object can have different values for the aƩributes defined by the class.
Example: Car
 “A Car class defines aƩributes like brand, color, mileage and behaviors like start() or
stop().”
 “car1 is an object that holds actual data. In this case, it stores MaruƟ as the brand and Red
as the color.”
class Car:
def __init__(self, brand, color):
self.brand = brand
self.color = color

car1 = Car("MaruƟ", "Red") # object

car1.brand=”MaruƟ” #we can assign variable like this also...but it is specific to car1 object,other
objects will not have this aƩribute
 class variables: Shared by all the objects in a class or common to all objects
 Instance variables: Belongs to an object,each object will have different values for it(they can
have same value also)
 __init__ (Constructor Method in Python)
 __init__ is a special (dunder) method that runs automaƟcally when an object is created.
 It is used to iniƟalize object’s instance variables (aƩributes).
 The first parameter is always self, which refers to the current object and stores the address
of that object in memory

## 꾅 Dunder Methods:

```
 Dunder = “Double UNDerscore”.
 These are special built-in methods like __init__, __str__, __len__ used to define specific
behaviors in classes.
```

#### Object and Constructor

When we write this
obj = Car()
Here’s what Python secretly does:
# internal steps
temp = Car.__new__(Car) # creates object in heap
if isinstance(temp, Car):
Car.__init__(temp) # iniƟalizes aƩributes
obj = temp # assign reference

When obj = Car() is executed, Python first calls __new__() to create a new Car object in heap
memory. The object reference returned by __new__() is passed to __init__() as self, where the
object’s variables are iniƟalized. AŌer iniƟalizaƟon, Python assigns the object reference to the
variable obj.....
Temp is just a variable used for explanaƟon perspecƟve,no temp variable exist in reality.
 temp → object reference returned by __new__
 That same reference is passed into __init__ as self
 Finally that reference is assigned to obj

1. Calls __new__() first →
    o Creates (allocates memory for) a new Car object in the heap.
    o Returns that object reference.
2. Then calls __init__() →
    o IniƟalizes the newly created object (sets up variables like self.brand, etc.).
3. Finally assigns the object reference to the variable obj in the stack.

```
 What is the purpose of self in Python classes?
 self represents the current object (instance) of the class.
It’s used to access instance variables and methods within the class.
```
귥극귧귨 OOP: Generic State vs Specific State vs Behaviour


QuesƟon: If class variables are stored in the class and not inside the object, then why can we
access them using the object reference (like obj.Name or obj.city)?
 Although class variables belong to the class, Python’s aƩribute lookup mechanism first
checks the instance and then the class. Since the variable is found in the class, it is returned,
which is why we can access class variables using the object reference.

#####  Python follows this lookup order:

#####  膆膊 Check inside the object (obj.__dict__)

##### 膆膋 If not found → check inside the class (School.__dict__)

##### 膆膌 If not found → check parent classes

In Object-Oriented Programming, every class is described using:

1. State → Data / variables
2. Behaviour → AcƟons / methods
State is further divided into:

```
 膆 Generic State (Class Variables)
 膆 Specific State (Instance Variables)
```
꾆 1) Generic State (Class Variables)

踰踱踲踳 DefiniƟon:
 Generic state refers to class-level data that is shared by all objects of that class.
 Same value for every object unless changed.
 Created outside __init__.

�� Example:


class School:
name = "Ex"
city = "B"
Here:
 name and city are class variables.
 Every School object shares them.

꾆 2) Specific State (Instance Variables)

踰踱踲踳 DefiniƟon:
 Specific state refers to instance-level data that is unique to each object of a class.
 Stored inside the object.
 Created using self inside __init__.
 Value depends on what the user passes.

�� Example:
class School:
name = "Ex" # generic
city = "B" # generic

def __init__(self, s_name):
self.s_name = s_name # specific
Here:
 s_name comes from the user.
 self.s_name becomes an instance variable.
 Each object can have a different s_name.

꾆 3) Behaviour (Methods)

踰踱踲踳 DefiniƟon:
Behaviour means the acƟons performed by the object.


 WriƩen as funcƟons inside the class.
 Always take self as first parameter.
 Can access both generic and specific state.
�� Example:
def grade(self):
return "A"
This method:
 Represents some acƟon.
 Returns a value.

### __new__() and __init__()

### 1) __new__() – Object CreaƟon

```
 __new__() is responsible for creaƟng (allocaƟng) the object.
```
#####  cls → refers to the class whose object is being created.

#####  super().__new__(cls) usually calls object.__new__(cls), which actually

##### allocates memory.

### 2) __init__() – Object IniƟalizaƟon

```
 __init__() is called aŌer the object is created, It iniƟalizes instance variables.
```
###  It receives the instance reference (self).


꾅 Types of Constructors:

1. Default Constructor → No parameters, sets fixed values.
2. Parameterized Constructor → Takes parameters for flexibility.
3. Non Parameterized Constructor- No parameters except self (Self is not a parameter it’s
    reference to object)
4. Combined Constructor → Uses default values; works as both.
    class Car:
    def __init__(self, brand="Tata", color="Blue"):
    self.brand = brand
    self.color = color
    obj1 = Car() # Uses default values
    obj2 = Car("Audi", "Red") # Uses given values


### Method

DefiniƟon:
A method is a funcƟon that is defined inside a class and is used to define the behavior (acƟons) of an
object.

Types:

膆 Instance Method —
It is a method that operates on instance variables of the class.
It takes self as its first parameter, which refers to the current object of the class.
Through self, it can access or modify the aƩributes of that object.

class Student:
school = 'Exsilience' # Class variable

def __init__(self, name): # Constructor
self.name = name # Instance variable

# Instance Method - Accessing aƩribute
def info(self):
return self.name

# Instance Method - Modifying aƩribute
def info(self, b):


self.name = b

ExplanaƟon:
 self.name = name → assigns the value to the object’s aƩribute.
 info(self) → accesses the value of self.name.
 info(self, b) → modifies the value of self.name.
Thus, Instance Methods are used to either access or modify the aƩributes of an object.

2.Class Method
DefiniƟon (Simple):
A class method is a method that works with the class itself, not with individual objects.
It can access or modify class-level variables that are shared by all objects.

How it works:
 It uses the @classmethod decorator.
 It takes cls (short for class) as the first parameter instead of self.
 cls refers to the class, just like self refers to the object.

Example:
class Student:
school = 'Exsilience' # class variable

@classmethod # decorator
def info(cls, b):
 cls.school = b # modify class variable(why cls,,,because school is a class variable.....if we
write only school the,it becomes normal variable)
return cls.school

# create object
obj = Student()

# call class method


print(Student.info('Upskilling'))
ExplanaƟon:
 @classmethod tells Python that this method belongs to the class, not to any object.
 cls.school = b changes the class variable school for all objects.
 When we call Student.info('Upskilling'), it changes school from 'Exsilience' → 'Upskilling'.

### Decorators

It allows us add extra funcƟonality to a funcƟon or method without changing its original code.
1.Class Method(same as method type)
2.StaƟc Method:
It is independent of class and object methods
it doesn’t use the class (cls) or object (self) inside it.

class Student:
@staƟcmethod
def info(a, b):
return a + b

obj = Student()
print(obj.info(1, 2))

@staƟcmethod is a decorator that tells Python this method doesn’t depend on any object or class
variable.

3.Property (Read Only)
 It allows you to access values like aƩributes but prevents modificaƟon (read-only means only
access).
 Access-read,modify-write
 You can access it using obj.info instead of obj.info().


class Student:
def __init__(self, a):
self.a = a

@property
def info(self):
return self.a * 2

obj = Student(4)
print(obj.info)

The decorator @property tells Python to treat the method like an aƩribute, not a funcƟon.

#### Inheritance

To inherit a class we have to do 3 things
1.include parent class in parentheses
2.include parent class aƩributes inside def __init__
3.super().__init__() -no self is included here only parent class aƩributes are included

膆膊 Calling Instance Methods
 Using an object:
obj = MyClass()
obj.method() # Calls method on the instance
 Inside another method:
def another_method(self):
self.method() # Calls the instance method on the same object
 Using super() in inheritance:
super().method() # Calls the next method in MRO aŌer the current class

```
  Not allowed in class body without an instance:
```
method() #  Error


膆膋 self vs super()

```
Call What it does
self.method() Looks for the method starfound. Ɵng from the current class, then parent classes if not
```
```
super().method() Looks for the method class. starƟng from the next class in MRO, skipping the current
 Use self.method() if child class doesn’t override the parent method.
 Use super().method() if child class overrides the parent method or in mulƟple inheritance
to follow MRO.
```

